import { join } from "node:path"
import { createInterface } from "node:readline/promises"
import { execa } from "execa"
import {
  contextRef,
  type IssueContext,
  fileExists,
  fireNeedInputHook,
  getConfig,
  getRepoRoot,
  ghRaw,
  git,
  log,
  logError,
  logStep,
  readFile,
} from "../utils.js"

/**
 * Step 8 â€” Optionally create the pull request.
 * Uses pr-description.md generated by the dedicated PR Description step.
 */
export async function stepCreatePR(ctx: IssueContext): Promise<boolean> {
  const cfg = getConfig()
  const descPath = join(ctx.issueDir, "pr-description.md")

  if (!fileExists(descPath)) {
    logError("Missing pr-description.md. Run pipeline from pr-description step.")
    return false
  }

  const prBody = readFile(descPath)

  // Skip PR creation if configured or declined
  if (cfg.prMode === "never") {
    logStep("Create PR", ctx, true)
    log("PR creation skipped (prMode=never)")
    return true
  }

  if (cfg.prMode === "ask") {
    await fireNeedInputHook(ctx)
    const shouldCreate = await askToCreatePR(ctx)
    if (!shouldCreate) {
      logStep("Create PR", ctx, true)
      log("PR creation declined")
      return true
    }
  }

  // Check if PR already exists
  if (await hasOpenPR(ctx.branch, ctx.repo)) {
    logStep("Create PR", ctx, true)
    return true
  }

  logStep("Create PR", ctx)

  // Push branch to remote
  await git(["push", "-u", cfg.remote, ctx.branch])

  // Append artifact links as footer
  const closesRef = ctx.number == null
    ? ""
    : ctx.repo === cfg.monorepo
      ? `Closes #${ctx.number}`
      : `Closes ${ctx.repo}#${ctx.number}`

  const artifactFooter = [
    "",
    "---",
    "",
    ...(closesRef ? [`${closesRef}`, ""] : []),
    "**Pipeline artifacts:**",
    `- Research: \`.auto-pr/${ctx.repoShort}/${ctx.id}/research.md\``,
    `- Plan: \`.auto-pr/${ctx.repoShort}/${ctx.id}/plan.md\``,
    `- Implementation plan: \`.auto-pr/${ctx.repoShort}/${ctx.id}/plan-implementation.md\``,
    `- Review: \`.auto-pr/${ctx.repoShort}/${ctx.id}/review.md\``,
    "",
    "_Generated by auto-pr pipeline_",
  ].join("\n")

  const fullBody = prBody + artifactFooter

  const createArgs = [
    "pr", "create",
    "--repo", ctx.repo,
    "--head", ctx.branch,
    "--title", ctx.title,
    "--body", fullBody,
    "--label", cfg.triggerLabel,
  ]

  // Create PR
  let prResult = await execa("gh", createArgs, { cwd: getRepoRoot(), reject: false })

  const labelMissing = /label.+not found|could not add label/i.test(`${prResult.stderr}\n${prResult.stdout}`)
  if (prResult.exitCode !== 0 && labelMissing) {
    log(`Warning: label "${cfg.triggerLabel}" not found in ${ctx.repo}; retrying PR creation without label.`)
    const argsWithoutLabel = createArgs.slice(0, -2)
    prResult = await execa("gh", argsWithoutLabel, { cwd: getRepoRoot(), reject: false })
  }

  const prUrl = (prResult.stdout || "").trim()

  if (prUrl) {
    log(`PR created: ${prUrl}`)
  } else {
    const detail = (prResult.stderr || prResult.stdout || "Unknown gh error").trim()
    logError(`Failed to create PR: ${detail}`)
    return false
  }

  return true
}

async function askToCreatePR(ctx: IssueContext): Promise<boolean> {
  if (!process.stdin.isTTY || !process.stdout.isTTY) {
    log(`Non-interactive shell: skipping PR creation for ${contextRef(ctx)} (prMode=ask)`)
    return false
  }

  const rl = createInterface({ input: process.stdin, output: process.stdout })
  try {
    const answer = await rl.question(`Create PR for ${contextRef(ctx)}? [y/N] `)
    return /^y(es)?$/i.test(answer.trim())
  } finally {
    rl.close()
  }
}

async function hasOpenPR(branch: string, repo: string): Promise<boolean> {
  const out = await ghRaw([
    "pr", "list",
    "--repo", repo,
    "--head", branch,
    "--state", "open",
    "--json", "number",
  ])
  try {
    const prs = JSON.parse(out)
    return Array.isArray(prs) && prs.length > 0
  } catch {
    return false
  }
}
